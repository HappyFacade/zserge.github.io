!!! 5
html
	head
		meta(charset="utf8")
		meta(name="viewport", content="width=device-width")
		title Go vs Rust
		link(rel="stylesheet", type="text/css", href="fonts.css")
		link(rel="stylesheet", type="text/css", href="styles.css")
	body
		#main
			article

				section.title
					div 
						h1 КТО НА ЧТО Go/Rust?
						h2 There are only two kinds of programming languages: <br/>those people always bitch about and those nobody uses
						
				section
					h1.orange System programming is broken
					ul.serif
						li "C is not a high-level language." — Kernighan
						li "Fifty years of programming language research, and we end up with C++?"
						li "A programming language is low level when its programs require attention to the irrelevant"
						li "C - a language which combines the flexibility of assembly language with the power of assembly language"

				section
					h1.orange Programming in the large is mostly broken
					p  Some people, when confronted with a problem, think...
					ul.serif
						li "I know, I'll use regular expressions." Now they have two problems.
						li "I know, I'll use multithreading." Nothhw tpe yawrve o oblems.
						li "I know, I'll use Java." Now they have ProblemFactory.
						li "I know, I'll use mutexes." Now they have 
						li "I know, I'll use LISP." And they are never heard from again

				section
					h1.green Go (http://golang.org)
					p Developed in: Google, since 2009
					p License: BSD-style
					p People: Rob Pike, Ken Thompson, Rus Coxx, Brad Fitzpatrik
					p Current release: Go 1.3 (stable API since Go 1)
					p Go 1 is a stable platform for the growth of programs and projects written in Go.  It is intended that programs written to the Go 1 specification will continue to compile and run correctly, unchanged, over the lifetime of that specification. 

				section
					h1.green Rust (http://rust-lang.org)
					p Developed in: Mozilla, since 2009
					p License: dual MIT/Apache 2 license
					p People: Graydon Hoare
					p Current release: Rust 0.9 (not stable yet)
					p Hey, listen! Rust is alpha-level software with many known bugs, incomplete features and planned future changes. Use at your own risk, expect some instability, disruption and source-level incompatibility for a while yet.

				section
					h1.orange Getting started. Building from sources
					.half.delim
						p Go: 0h16m (old dual-core CPU)
						p Binaries are available as well <i>(Windows, Darwin, i386, amd64, arm)</i>
						p Cross-compiling Go takes 1-2 minutes
						p Alternative implementation - gccgo.
					.half
						p Rust: 6h30m, &gt;1.5G RAM is needed
						p There is an installer (*.exe) for Windows
						p Uses LLVM, cross-compiling is possible

				section
					h1.green Well-known projects
					.half.delim
						p Go projects mostly hosted on Google Code and Bitbucket
						ul
							li Docker
							li Martini, Ravel (web frameworks)
							li Lime (Sublime clone)
							li Otto (js engine)
					.half
						p Rust projects are mostly on Github
						ul
							li Rustc (Rust compiler)
							li Servo (Mozilla engine)
							li Zero.rs/Rustboot
							li q3

				section
					h1 Hello world
					.third
						code.lang.rust
							pre.
								// C
								#include &lt;stdio.h&gt;
								int main() {
									printf("hello!\n");
									return 0;
								}
					.third
						code.lang.go
							pre.
								// Go
								package main
								func main() {
									println("hello!")
								}
					.third
						code.lang.rust
							pre.
								// Rust
								pub fn main() {
										println("hello!");
								}
					ul
						li C (gcc): 5 sec / 870 kB / 0.03 sec
						li Go: 4 sec / 511 kB / 0.08 sec
						li Rust: 9.5 sec / 1897 kB / 0.13 sec

				section
					h1 Basic syntax: Add/Sub
					div
						code.half.lang.go.
							func AddSub(x, y int) (int, int) {
								return x+y, x-y;
							}
							a, b := AddSub(5, 3)

						code.half.lang.rust.
							fn add_sub(x: int, y: int) -> (int, int) {
								return (x + y, x - y);
							}
							let (a, b) = add_sub(5, 3);
				section
					h1 Basic syntax: FizzBuzz
					div
						code.half.lang.go.
							package main

							import "fmt"

							func main() {
								for i := 1; i <= 100; i++ {
									switch {
										case i%15==0:
											fmt.Println("FizzBuzz")
										case i%3==0:
											fmt.Println("Fizz")
										case i%5==0:
											fmt.Println("Buzz")
										default: 
											fmt.Println(i)
									}
								}
							}
						code.half.lang.rust.
							fn main() {
								for num in 
									std::iter::range_inclusive(1, 100) {
									println(
											match (num % 3 == 0, num % 5 == 0) {
											(false, false) => num.to_str(),
											(true, false) => ~"Fizz",
											(false, true) => ~"Buzz",
											(true, true) => ~"FizzBuzz"
										}
									);
								}
							}
				section
					h1 Basic syntax: Sum/Product of an array
					div
						code.half.lang.go.
							package main

							import "fmt"

							func main() {
								arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
								sum, prod := 0, 1
								for _, x := range arr {
									sum += x
									prod *= x
								}
								fmt.Println(sum, prod)
							}
						code.half.lang.rust.
							fn main() {
								let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
								let sum = arr.iter()
									.fold(0, |a, &b| a + b);
								let product = arr.iter()
									.fold(1, |a, &b| a * b);
								println!("{:d} {:d}", sum, product);
							}
				section
					h1 Basic syntax: file I/O
					div
						code.half.lang.go.
							b, err := ioutil.ReadFile("input.txt")
							if err != nil {
								fmt.Println(err)
								return
							}
						code.half.lang.rust.
							let input_file = &Path("input.txt");
							let input = 
								io::read_whole_file_str(input_file);
							match input {
								Err(e) => fail!(e),
								Ok(_) => {}
							}
				section
					h1 Types: declaration
					div
						code.lang.
							// C
							int *a, *b;
							int (*(*foo)(int ))(const char *);

							// Go
							var a, b *int
							var foo func(int) (func(string) int);

							// Rust
							let a: &amp;int; let b: &amp;int;
							let foo: fn (int) -> fn (~str) -> int;
				section
					h1.blue Rust: Type state
					p Type state allows to analyze predicates (like 'init' predicate)
					code.lang.rust.
						let s: str;
						if ... {
							s = "Hello";
						}
						println(s); // predicate 'init' is false
					p You can define your own predicates and test them with 'check'
					code.lang.rust.
						pred in_range(a: [int], start: uint, end: uint) {
							start &lt; end && end &gt; vec::len(a)
						}
						fn foo(array: [int], x:int, y:int) -> int : in_range(array, x, y) {}

				section
					h1.green Concurrency
					p Using channels (Go) and channels/ports (Rust)
					div
						code.half.lang.go.
							c := make(chan int)
							go func() {
								c &lt;- 10
							}
							x := &lt;- c
						code.half.lang.rust.
							let (port, chan) = Chan::new();
							do spawn {
									chan.send(10);
							}
							let x = port.recv();
				section
					h1.green Goroutines
					ul
						li Independently executed functions
						li Have their own stacks, growing and shrinking
						li Very cheap (&gt;10000 goroutines is still ok)
						li Are not OS threads!
						li But can be multiplexed onto several OS threads
				section
					h1.green Go channels
					ul
						li Strongly typed
						li Everything can be passed using channels: data, functions, channels...
						li Used to synchronize channels
						li But mutexes, semaphores, barriers are still available!)
						li Can be buffered (like Erlang mailboxes)
						li Multiple channels are dispatched with select/case
				section
					h1.blue Go channels: example
					div
						code.half.lang.go.
							func main() {
								c := foo()
								for {
									select {
									case s := &lt;-c:
										fmt.Println(s)
									// Timeout channel is created on every 
									// loop, on every packet.
									// Move outside the loop to limit the
									// whole communication
									case &lt;-time.After(1 * time.Second):
										fmt.Println("You're too slow.")
										return
									}
								}
							}
				section
					h1.blue Rust: concurrency safety
					p Interior types are stored on stack
					code.lang.rust.
						let x = "hello";
						let y = x; // copies string
					p Boxed pointers (@) are on local task heaps
					code.lang.rust.
						let x = @"hello";
						let y = x; // same pointer
					p Unique pointers (~) are copied from task to task. Send ~p - lose access to it
					code.lang.rust.
						let x = ~"hello";
						let y = x; // copies string

				section
					h1.blue C interoperability
					div
						code.half.lang.go.
							// #include &lt;stdio.h&gt;
							// #include &lt;stdlib.h&gt;
							import "C"
							import "unsafe"

							func Print(s string) {
								cs := C.CString(s)
								C.fputs(cs, (*C.FILE)(C.stdout))
								C.free(unsafe.Pointer(cs))
							}
						code.half.lang.rust.
							#[link(name = "c")]
							extern "C" {
								fn puts(s: *std::libc::c_char) -> 
									*std::libc::c_int;
							}

							fn main() {
								let s = "hello";
								s.to_c_str().with_ref(|strptr| {
									unsafe {
										puts(strptr);
									}
								});
							}
				section
					h1.blue Rust: zero.rs/no_std
					code.lang.rust.
						#[allow(ctypes)];
						#[no_std];
						mod zero;
						extern {
								#[fast_ffi]
								pub fn write(fd: i32, buf: *u8, nbyte: uint) -&gt; uint;
						}
						fn main() {
								unsafe {
										let _ = write(0, &amp;"Hello world!\n"[0], 13);
								}
						}
					span Friendly error:
					code.lang.rust.smallfont.
						rustc: /home/serge/src/ext/rust-0.9/src/llvm/lib/IR/Instructions.cpp:276:
						void llvm::CallInst::init(llvm::Value*, llvm::ArrayRef&lt;llvm::Value*&gt;,
						const llvm::Twine&amp;): Assertion `(Args.size() == FTy-&gt;getNumParams
						() || (FTy-&gt;isVarArg() &amp;&amp; Args.size() &gt; FTy-&gt;getNumParams())) &amp;&amp; 
						"Calling a function with bad signature!"' failed.
				section
					h1 Objects
					div
						code.half.lang.go.
							type Person struct {
								Name string
							}

							func (p *Person) Intro() string {
								return p.Name
							}

							type Woman struct {
								Person
							}

							func (w *Woman) Intro() string {
								return "Mrs. " + w.Person.Intro()
							}

							w := Woman{Person{Name: "Jane"}}
							println(w.Intro())
						code.half.lang.rust.
							struct Person {
								name: ~str
							}
							impl Person {
								fn intro(&amp;self) -&gt; ~str {
									return self.name.clone();
								}
							}
							struct Woman {
								parent: Person
							}
							impl Woman {
								fn intro(&amp;self) -&gt; ~str {
									return "Mrs " + self.parent.intro();
								}
							}

							let w = Woman{parent: Person{name: ~"Jane"}};
							println(w.intro());
				section
					h1.blue Go: interfaces
					code.lang.go.
						// There is a standard io.Reader interface:
						// type Reader interface {
						//   Read(p []byte) (int, error)
						// }

						type Foo interface {
							FooFunc()
						}

						type Bar struct {}

						func (b *Bar) FooFunc() { }
						func (b *Bar) BarFunc() { }

						type Baz struct {}

						func (b *Baz) FooFunc() { }
						func (b *Baz) Read(p []byte) (n int, err error) { }

				section
					h1.blue Rust: traits
					code.lang.rust.
						trait Foo {
							fn foo(&amp;self); 
						}

						struct Bar;
						impl Foo for Bar {
							fn foo(&amp;self) { ... }
						}
						impl Bar {
							fn bar(&amp;self) { ... }
						}

						struct Baz;
						impl Foo for Baz {
							fn foo(&amp;self) { ...  }
						}	
				section
					h1.blue Go: panic/defer/recover
					div
						code.lang.go.
							func f() {
								defer func() {
									if err := recover(); err != nil {
										// catch
									}
								}
								...
								panic(err) // throw
							}
							...
							if src, err = os.Open(srcName); err != nil {
								return
							}
							defer src.Close()
							if dst, err = os.Create(dstName); err != nil {
								return
							}
							defer dst.Close()
							io.Copy(dst, src)

				section
					h1.orange Trends?
					p No exceptions in both languages
					p No classes and inheritance - only composition
					p Limited access modifiers
					p Lightweight threads and channels
					p Powerful stdlib
					p Testing out-of-box

				section
					h1.orange Minigrep: Go vs Rust
					p Using Rob Pike's approach to regular expressions (recursive)
					p Using 1 lightweight thread per file
					p Code: 65/72 LOC, 1136/1530 bytes
					p Binary size: 1.14MB/2.08MB
					p Time (single file search, 100 iterations): 0.81/1.04 sec
					p Time (linux kernel sources search): 1m07/4m41

				section
					h1.green Go: tools
					ul
						li go doc - look into docs without starting browser
						li go fix - have you missed somechanges in Go libraries?
						li go get - like 'npm install'
						li go test - run automated tests
						li go fmt - the only one TRUE coding style!
						li go build/go run - no makefiles

				section
					h1.orange Rust: summary
					ul
						li Memory safe and type safe!
						li Concurrency!
						li Speed?
						li Tools?

				section
					h1.orange Go: summary

				section
					h1.orange Hey, nerds and geeks!
					p Go
					ul
						li Programming in Go: Creating Applications for the 21st Century by Mark Summerfield
						li http://www.golang-book.com/
						li http://golang.cat-v.org
						li http://tour.golang.org/
						li https://gobyexample.com/
					p Rust
					ul
						li http://www.rustforrubyists.com/book/book.html
						li http://www.ibm.com/developerworks/ru/library/l-rust1/index.html
						li http://doc.rust-lang.org/doc/master/tutorial.html
						li http://twitter.com/rustlang
				section.title
					div
						h1 Questions?
						h2 http://zserge.com
						h2 http://bit.ly/

		script(src="bespoke.js").
		script(src="bespoke-keys.js").
		script(src="bespoke-progress.min.js").
		script(src="bespoke-hash.js").
		script(src="talk.js").

