<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>The most simple JSON parser in C for small systems</title>
		<meta name="description" content="Minimalist open-source software for *nix and embedded systems" />
		<meta name="keywords" content="json, parse, c, unix, embedded, KISS, minimal, memory allocation" />
		<link href='/font/stylesheet.css' rel='stylesheet' type='text/css'>
		<link href='http://fonts.googleapis.com/css?family=Corben' rel='stylesheet' type='text/css'>
		<link rel="stylesheet" type="text/css" href="/style.css" />
		<script type="text/javascript">

			var _gaq = _gaq || [];
			_gaq.push(['_setAccount', 'UA-33644825-1']);
			_gaq.push(['_trackPageview']);

			(function() {
			 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
			 })();

		 </script>
	</head>
	<body>
		<div class='menu'>/*
			<ul class='menu'>
				<li><a href="/">home</a></li>
				<li><a href="/projects.html">code</a></li>
				<li><a href="/blog.html">blog</a></li>
			</ul>*/
		</div>
		<h1>JSMN</h1>
<p>jsmn (pronounced like 'jasmine') is a minimalistic JSON parser in C.  It can be
easily integrated into resource-limited or embedded projects.</p>
<p>You can find more information about JSON format at <a href="http://www.json.org/">json.org</a></p>
<p>Library sources are available at <a href="https://bitbucket.org/zserge/jsmn/wiki/Home">bitbucket.org/zserge/jsmn</a></p>
<h2>Philosophy</h2>
<p>Most JSON parsers convert JSON string to internal object representation.
But if you are using C it becomes more tricky. There is no objects or hash 
tables. That's why most JSON parsers written in C try to reinvent the wheel, 
and either invent custom JSON-like objects, custom hash maps, or use callbacks
like SAX parsers do.</p>
<p>jsmn is parser for those who don't accept it.</p>
<p>jsmn is designed to be  <strong>robust</strong> (it should work fine even with erroneous
data), <strong>fast</strong> (it should parse data on the fly), <strong>portable</strong> (no superfluous
dependencies or non-standard C extensions). An of course, <strong>simplicity</strong> is a
key feature - simple code style, simple algorithm, simple integration into
other projects.</p>
<h2>Features</h2>
<ul>
<li>compatible with C89</li>
<li>no dependencies (even libc!)</li>
<li>highly portable (tested on x86/amd64, ARM, AVR)</li>
<li>about 200 lines of code</li>
<li>extremely small code footprint</li>
<li>API contains only 2 functions</li>
<li>no dynamic memory allocation</li>
<li>incremental single-pass parsing</li>
<li>library code is covered with unit-tests</li>
</ul>
<h2>Design</h2>
<p>The rudimentary jsmn object is a <strong>token</strong>. Let's consider a JSON string:</p>
<pre><code>'{ "name" : "Jack", "age" : 27 }'
</code></pre>
<p>It holds the following tokens:</p>
<ul>
<li>Object: <code>{ "name" : "Jack", "age" : 27}</code> (the whole object)</li>
<li>Strings: <code>"name"</code>, <code>"Jack"</code>, <code>"age"</code> (keys and some values)</li>
<li>Number: <code>27</code></li>
</ul>
<p>The key moment is that in jsmn, tokens <strong>do not hold any data</strong>, 
but just point to the token boundaries in JSON string instead. 
In the example above jsmn will create tokens like: </p>
<ul>
<li>Object [0..31]</li>
<li>String [3..7], String [12..16], String [20..23]</li>
<li>Number [27..29].</li>
</ul>
<p>As you can see, every jsmn token has a type, which indicates the type of 
corresponding JSON token. </p>
<p>jsmn supports the following token types:</p>
<ul>
<li>Object - a container of key-value pairs, e.g.:
    <code>{ "foo":"bar", "x":0.3 }</code></li>
<li>Array - a sequence of values, e.g.:
    <code>[ 1, 2, 3 ]</code></li>
<li>String - a quoted sequence of chars, e.g.: <code>"foo"</code></li>
<li>Primitive - a number, a boolean (<code>true</code>, <code>false</code>) or <code>null</code></li>
</ul>
<p>Besides start/end positions, jsmn tokens for complex types (like arrays
or objects) also contain a number of child items, so you can easily follow
object hierarchy.</p>
<p>This approach provides enough information for parsing any JSON data and makes
it possible to use zero-copy techniques.</p>
<h2>Install</h2>
<p>To clone the repository you should have mercurial installed. Just run:</p>
<pre><code>$ hg clone http://bitbucket.org/zserge/jsmn jsmn
</code></pre>
<p>Repository layout is simple: jsmn.c and jsmn.h are library files; demo.c is an
example of how to use jsmn (it is also used in unit tests); test.sh is a test
script. You will also find README, LICENSE and Makefile files inside.</p>
<p>To build the library, run <code>make</code>. It is also recommended to run <code>make test</code>.
Let me know, if some tests fail.</p>
<p>If build was successful, you should get a <code>libjsmn.a</code> library.
The header file you should include is called <code>"jsmn.h"</code>.</p>
<h2>API</h2>
<p>Token types are described by <code>jsmntype_t</code>:</p>
<pre><code>typedef enum {
    JSMN_OBJECT,
    JSMN_ARRAY,
    JSMN_STRING,
    JSMN_PRIMITIVE
} jsmntype_t;
</code></pre>
<p><strong>Note:</strong> Unlike JSON data types, primitive tokens are not divided into
numbers, booleans and null, because one can easily tell the type using the
first character:</p>
<ul>
<li><code>'t', 'f'</code> - boolean </li>
<li><code>'n'</code> - null</li>
<li><code>'-', '0'..'9'</code> - number</li>
</ul>
<p>Token is an object of <code>jsmntok_t</code> type:</p>
<pre><code>typedef struct {
    jsmntype_t type; /* Token type */
    int start;       /* Token start position */
    int end;         /* Token end position */
    int size;        /* Number of child (nested) tokens */
} jsmntok_t;
</code></pre>
<p><strong>Note:</strong> string tokens point to the first character after
the opening quote and the previous symbol before final quote. This was made 
to simplify string extraction from JSON data.</p>
<p>All job is done by <code>jsmn_parser</code> object. You can initialize a new parser using:</p>
<pre><code>struct jsmn_parser parser;

jsmn_init_parser(&amp;parser);
</code></pre>
<p>This will initialize (reset) the parser.</p>
<p>Later, you can use <code>jsmn_parse()</code> function to process JSON string with the 
parser:</p>
<pre><code>jsmntok_t tokens[256];
const char *js;
js = ...;

r = jsmn_parse(&amp;parser, js, tokens, 256);
</code></pre>
<p>If something goes wrong, you will get an error returned by <code>jsmn_parse()</code>. 
Return value will be one of these:</p>
<ul>
<li><code>JSMN_SUCCESS</code> - everything went fine. String was parsed</li>
<li><code>JSMN_ERROR_INVAL</code> - bad token, JSON string is corrupted</li>
<li><code>JSMN_ERROR_NOMEM</code> - not enough tokens, JSON string is too large</li>
<li><code>JSMN_ERROR_PART</code> - JSON string is too short, expecting more JSON data</li>
</ul>
<p>If you get <code>JSON_ERROR_NOMEM</code>, you should re-allocate more tokens and call
<code>jsmn_parse</code> once more.  If you read json data from the stream, you can
periodically call <code>jsmn_parse</code> and check if return value is <code>JSON_ERROR_PART</code>.
You will be receiving this error until you reach the end of JSON data.</p>
<p>jsmn stored only offsets inside parser structure, not pointers.
It means you can use realloc() to get more tokens, or reallocated your
<code>js</code> string when more data arrives.</p>
<h2>Non-strict mode</h2>
<p>By default jsmn is build in a non-strict mode. It allows you to use it for 
other useful formats that JSON. In non-struct mode jsmn accepts:</p>
<ul>
<li>non-quoted primitive values other than true/false/null/numbers</li>
<li>only primitive values without a root object</li>
</ul>
<p>It means the following strings will be parsed, too:</p>
<pre><code>server: example.com
post: 80
message: "hello world"
</code></pre>
<p>Looks like a config file, right? </p>
<pre><code>{
    server: "example.com",
    post: 80,
    message: "hello world"
}
</code></pre>
<p>And this is how you can use jsmn to parse JavaScript code.</p>
<p>To switch to strict mode you should define <code>JSMN_STRICT</code> preprocessor variable.</p>
<h2>Other info</h2>
<p>This software is distributed under <a href="http://www.opensource.org/licenses/mit-license.php">MIT license</a>,
 so feel free to integrate it in your commercial products.</p>
	</body>
</html>
